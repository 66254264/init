package me.reezy.init.processor

import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.*
import java.io.File
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.TypeElement
import javax.lang.model.util.Types
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import me.reezy.init.annotation.Init


private const val WARNINGS = """
   ******************************************************
   * THIS CODE IS GENERATED BY Initiator, DO NOT EDIT.  *
   ******************************************************
"""


private const val PKG = "me.reezy.init"
private const val PKG_GEN = "$PKG.generated"
private const val PKG_ANN = "$PKG.annotation"

@AutoService(Processor::class)
@SupportedOptions("moduleName")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@SupportedAnnotationTypes(value = ["$PKG_ANN.Init"])
class InitProcessor : AbstractProcessor() {


    protected lateinit var mTypes: Types
    protected lateinit var mLogger: Logger
    protected lateinit var mModuleName: String
    protected lateinit var mOriginalModuleName: String

    override fun init(env: ProcessingEnvironment) {
        super.init(env)
        mTypes = env.typeUtils
        mLogger = Logger(env.messager, PKG)

        val options = env.options
        if (options.isNotEmpty()) {
            mOriginalModuleName = options["moduleName"] ?: ""
            mModuleName = mOriginalModuleName.replace("[^0-9a-zA-Z_]+".toRegex(), "")
        }
        mLogger.info("[$mOriginalModuleName] ${this::class.java.simpleName} init")
    }

    override fun process(set: MutableSet<out TypeElement>, roundEnv: RoundEnvironment): Boolean {

        if (set.isEmpty()) {
            return false
        }

        if (mOriginalModuleName.isBlank()) {
            mLogger.warning("this module name is null!!! skip this module!!")
            return false
        }

        try {
            mLogger.info("[$mOriginalModuleName] ${this::class.java.simpleName} process!!!")
            generate(roundEnv)
        } catch (e: Throwable) {
            mLogger.error(e)
        }

        return true
    }

    private fun FileSpec.writeFile() {
        val outputFile = File(processingEnv.options["kapt.kotlin.generated"])
        outputFile.mkdirs()
        writeTo(outputFile.toPath())
    }

    private fun tm(tm: String) = processingEnv.elementUtils.getTypeElement(tm).asType()

    private fun generate(roundEnv: RoundEnvironment) {
        val elements = roundEnv.getElementsAnnotatedWith(Init::class.java)
        if (elements.isEmpty()) {
            return
        }
        mLogger.info("Found ${elements.size} init in [$mOriginalModuleName]")

        val tmInitializer = tm("$PKG.InitTask")
//        val tmTask = tm("$PKG.Task")
        val tmTaskList = tm("$PKG.TaskList")

//        val itemsType = ClassName("kotlin.collections", "ArrayList").parameterizedBy(tmTask.asTypeName())

        val funcSpec = FunSpec.builder("load").addParameter("l", tmTaskList.asTypeName()).addParameter("index", INT)

        elements.forEach {
            val an = it.getAnnotation(Init::class.java)

            if (mTypes.isSubtype(it.asType(), tmInitializer)) {
                mLogger.info("Found ${it.asType()}")

                funcSpec.addStatement("l.add(%S, index, %T::class.java, %S, %L, %L, %L, %L)", mModuleName, it.asType(), an.process, an.background, an.debugOnly, an.priority, an.depends.format(an.compliance))

            } else {
                mLogger.info("Unknown init type, so skip ${it.asType()}")
            }
        }

        val typeSpec = TypeSpec.classBuilder("InitLoader_$mModuleName")
                .addKdoc(WARNINGS)
                .addFunction(funcSpec.build())
                .build()

        val kotlinFile = FileSpec.builder(PKG_GEN, "InitLoader_$mModuleName")
                .addType(typeSpec)
                .build()

        kotlinFile.writeFile()
    }

    private fun Array<String>.format(compliance: Boolean): String {
        val depends = if (compliance) this + ":compliance" else this
        if (depends.isEmpty()) return "setOf()"
        return depends.joinToString("\", \"", "setOf(\"", "\")") {
            if (it.contains(":")) it else "$mModuleName:$it"
        }
    }
}




